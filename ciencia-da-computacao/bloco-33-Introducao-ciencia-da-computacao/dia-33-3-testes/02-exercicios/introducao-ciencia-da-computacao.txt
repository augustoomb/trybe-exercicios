DIA 01 - APRENDENDO PYTHON

    ==========================================

    IMPORTANTE (ANTES DE TUDO) (Atualiza√ß√£o: ambientes s√£o vistos no dia 2 ver mais abaixo)

        Preciso criar um ambiente para trabalhar programa√ß√£o com python. O course diz abaixo que j√° tem o Python no sistema (e √© verdade), mas se eu fizer besteira nessa instancia no python, POSSO PERDER O SO

        Por isso √© fundamental criar um ambiente virtual. Tem um t√≥pico mais abaixo.

    ===========================================


    Terminal Interativo (REPL)

        OBS: As distribui√ß√µes do sistema operacional Linux e Mac, normalmente, j√° vem com uma vers√£o Python instalada, pois utilizam a linguagem em diversos programas essenciais. Vamos verificar isto abrindo um terminal e digitando python3. A sa√≠da deve ser semelhante a esta:        

            Python 3.8.2 (default, Jun  2 2020, 13:51:17)
            [GCC 9.3.0] on linux
            Type "help", "copyright", "credits" or "license" for more information.
            >>>
                
        Este tipo de terminal √© chamado de REPL (Read-Eval-Print Loop), sendo traduzido para o portugu√™s como loop de leitura-avalia√ß√£o-impress√£o ou terminal interativo. Esse terminal recebe uma entrada digitada pela pessoa, avalia sua execu√ß√£o e imprime seu resultado.
        

    ------------------------------------------------------------------------------------------------    
    

    Python no Docker (opcional no m√≥dulo de cs)     

        Op√ß√£o 01: Usar o REPL do Python dentro do Docker. Para isso siga as instru√ß√µes abaixo:      

            -> Baixe a imagem do python.

                # Baixe a √∫ltima vers√£o do python
                docker pull python

                # Baixe uma vers√£o espec√≠fica
                docker pull python:tag

                Observa√ß√£o: troque a palavra tag pela vers√£o desejada.



            -> Execute o REPL a partir da imagem baixada:

                docker run -it --rm python:tag


            -> Para fechar o REPL basta executar exit() ou o atalho Ctrl-D.


        ------
        
        Op√ß√£o 02 : Criar um Dockerfile para o seu projeto como mostrado abaixo. Voc√™ pode notar que, um dos passos do Dockerfile √© realizar um pip install recebendo como par√¢metro o arquivo requirements.txt, o qual representa a listagem de bibliotecas necess√°rias para a execu√ß√£o de um projeto. No momento, iremos trabalhar apenas com o pacote padr√£o do Python, portanto, por ora basta voc√™ criar este arquivo vazio no mesmo n√≠vel do Dockerfile.

            FROM python:3

            WORKDIR /usr/src/app

            COPY requirements.txt ./
            RUN pip install --no-cache-dir -r requirements.txt

            COPY . .

            CMD [ "python", "./seu-arquivo.py" ]




            Agora voc√™ pode construir e rodar a imagem Docker:

                docker build -t my-python-app .

                docker run -it --rm --name my-running-app my-python-app



        -------
        
        Op√ß√£o 03: Para muitos projetos simples de arquivo √∫nico, voc√™ pode achar inconveniente escrever um Dockerfile completo. Nesses casos, execute um script Python usando a imagem de Python do Docker diretamente:

            docker run -it --rm --name nome-do-seu-script -v "$PWD":/usr/src/myapp -w /usr/src/myapp python:3 python seu-arquivo.py
            # -v "$PWD":/usr/src/myapp - monta o diret√≥rio atual para dentro do cont√™iner
            # -w /usr/src/myapp - muda o WORKDIR para executar o comando no diret√≥rio rec√©m montado.
        



    -------------------------------------------------------------------------------------
    
    Opera√ß√µes b√°sicas

        Bora praticar algumas opera√ß√µes b√°sicas como adi√ß√µes e multiplica√ß√µes!? Digite as opera√ß√µes abaixo e veja que o valor ser√° avaliado e impresso.

            2 * 3  # sa√≠da: 6
            2 + 3  # sa√≠da: 5
            3 / 2  # sa√≠da: 1.5


            De olho na dicaüëÄ: O s√≠mbolo # marca um coment√°rio e deste simbolo em diante (na linha) o c√≥digo n√£o ser√° executado.



        Para atribuir esses valores a um nome, basta utilizar o operador de atribui√ß√£o =, conforme o exemplo a seguir:

            square_root = 25 ** (1/2)  # raiz quadrada de 25. O operador `**` significa "elevado a"

            print(square_root + 1)  # sa√≠da: 6.0

        Aviso: N√£o √© necess√°rio a utiliza√ß√£o de let, var ou const nas atribui√ß√µes. Veremos escopo e quest√µes de mutabilidade mais adiante.



        Observe o que vai acontecer no exemplo a seguir:

            counter = 0
            counter++  # esse c√≥digo vai falhar

        Ainda que possamos simplificar opera√ß√µes e atribui√ß√µes, o incremento ou decremento n√£o √© v√°lido na sintaxe ++, --.



        Um exemplo de simplifica√ß√£o v√°lida √©:
    
            # original
            counter = counter + 1

            # simplificado
            counter += 1




        Um outro operador um pouco diferente √© o //. Consegue imaginar para sua fun√ß√£o dentro do c√≥digo?ü§î Observe o exemplo abaixo:

            3 // 2  # sa√≠da: 1 - // realiza a divis√£o e arredonda o resultado para baixo. Ou seja, realiza o quociente.

            3 / 2  # sa√≠da: 1.5




        Voc√™ pode estar pensando:‚Äù Hummm‚Ä¶ Tirando o let e var, ainda parece bem similar com Javascript‚Äú.        
        
        De fato, operadores s√£o comuns a todas as linguagens de programa√ß√£o. Entretanto, nem tudo √© semelhante. Por exemplo, se realizarmos a opera√ß√£o de compara√ß√£o '1' == 1, o resultado ser√° falso (False), pois como s√£o valores de tipos diferentes, nenhuma convers√£o √© realizada.

        Dado as listas a = [1, 2, 3] e b = [1, 2, 3], se compararmos as duas a == b teremos como retorno True, ainda que representem listas diferentes.





        Mas e sobre os operadores && e ||, n√£o s√£o opera√ß√µes de and e or?

            Resposta: Quando queremos fazer opera√ß√µes l√≥gicas, como verificar se uma temperatura est√° entre dois valores, utilizamos o operador and. Ou seja, para verificar se uma temperatura √© menor que 25 graus e maior que 18 graus, podemos fazer algo como temperatura < 25 and temperatura > 18. Embora uma maneira mais pythonica de se escrever esta opera√ß√£o seja 18 < temperatura < 25.


        Da mesma forma, podemos validar intervalos utilizando o operador or. Por exemplo, se em um parque pessoas com idade menor ou igual a 5 e maiores de 65 anos n√£o pagam, poder√≠amos escrever uma valida√ß√£o da seguinte maneira idade <= 5 or idade >= 65.





    

    --------------------------------------------------------------------------------------------------
    Tipos de dados embutidos

        Booleanos (bool)
    
            Os valores booleanos True e False pertencem ao tipo embutido bool.

            De olho na dicaüëÄ: Aqui devemos ter aten√ß√£o ao in√≠cio mai√∫sculo dessas palavras reservadas.


        
        N√∫meros inteiros (int)
        
            O primeiro dos tipos num√©ricos √© o int, ele representa um n√∫mero inteiro, ou seja, √© escrito sem parte fracion√°ria.

            Inicialize uma vari√°vel a = 5, digite o comando type(a) e observe o retorno.

            Anota a√≠ ‚úèÔ∏è: O m√©todo type(operando) corresponde ao operador typeof operando do JavaScript.



        Dicas:

            De olho na dicaüëÄ: Assim como qualquer linguagem de programa√ß√£o, Python tamb√©m possui uma grande quantidade de comandos que precisamos aprender. Para nos ajudar nessa tarefa, podemos digitar help() dentro da linha de comandos do Python que ele nos dar√° detalhes do comando passado por par√¢metro. Exemplo:

                help(list)

            O comando help() tamb√©m pode ser utilizado em cl√°usulas if ou for, desde que colocado entre aspas e para sair de dentro do comando, basta apertar a tecla q.



        N√∫meros fracion√°rios (float)

            O segundo tipo num√©rico √© o float, tamb√©m conhecido por ponto flutuante, ele representa um n√∫mero decimal ou fracion√°rio.

                Inicialize uma vari√°vel a = 5.0, digite o comando type(a) e observe o retorno.


        
        Strings (str)
            
            Al√©m dos tipos num√©ricos, temos o tipo de sequ√™ncia de texto str. Ele representa uma cadeia de caracteres ou, como popularmente conhecida, uma string. As strings s√£o definidas envolvendo um valor com aspas simples ou duplas. Exemplo: a = "Ol√°"



        Temos ainda estruturas do tipo:

            sequ√™ncia(list, tuple, range);
            conjuntos(set, frozenset);
            mapeamento(dict);
            sequ√™ncias bin√°rias(bytes, bytearray, memoryview).


        Al√©m dessas temos v√°rias outras, que voc√™ pode encontrar acessando os links abaixo:

            Tipos padr√µes do Python (https://docs.python.org/3/library/stdtypes.html)

            Outros tipos de dados do Python (https://docs.python.org/3/library/datatypes.html)




        ---------
        Listas (list)

            uma lista √© uma sequ√™ncia mut√°vel e ordenada de elementos. Ela pode armazenar elementos heterog√™neos, ter seu tamanho vari√°vel e crescer √† medida que itens s√£o adicionados:


                fruits = ["laranja", "ma√ß√£", "uva", "abacaxi"]  # elementos s√£o definidos separados por v√≠rgula, envolvidos por colchetes

                fruits[0]  # o acesso √© feito por √≠ndices iniciados em 0

                fruits[-1]  # o acesso tamb√©m pode ser negativo

                fruits.append("banana")  # adicionando uma nova fruta

                fruits.remove("abacaxi")  # removendo uma fruta

                fruits.extend(["pera", "mel√£o", "kiwi"])  # acrescenta uma lista de frutas a lista original

                fruits.index("ma√ß√£")  # retorna o √≠ndice onde a fruta est√° localizada, neste caso, 1

                fruits.sort()  # ordena a lista de frutas



            De olho na dicaüëÄ: Fun√ß√µes e vari√°veis devem ser nomeadas com letras min√∫sculas e, caso tenham mais de uma palavra, com underscore: minha_variavel.


        
        ---------
        Tuplas (tuple)

            S√£o similares a listas, por√©m n√£o podem ser modificados durante a execu√ß√£o do programa.

                user = ("Will", "Marcondes", 42)  # elementos s√£o definidos separados por v√≠rgula, envolvidos por par√™nteses

                user[0]  # acesso tamb√©m por √≠ndices




        ----------
        Conjuntos (set)

            Um conjunto √© uma cole√ß√£o de elementos √∫nicos e n√£o ordenados. Conjuntos implementam opera√ß√µes de uni√£o, intersec√ß√£o e outras.

                permissions = {"member", "group"}  # elementos separados por v√≠rgula, envolvidos por chaves

                permissions.add("root")  # adiciona um novo elemento ao conjunto

                permissions.add("member")  # como o elemento j√° existe, nenhum novo item √© adicionado ao conjunto

                permissions.union({"user"})  # retorna um conjunto resultado da uni√£o

                permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

                permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos



        
        ----------
        Conjuntos imut√°veis (frozenset)

            √â uma varia√ß√£o do set, por√©m imut√°vel, ou seja, seus elementos n√£o podem ser modificados durante a execu√ß√£o do programa.

                permissions = frozenset(["member", "group"])  # assim como o set, qualquer estrutura iter√°vel pode ser utilizada para criar um frozenset

                permissions.union({"user"})  # novos conjuntos imut√°veis podem ser criados √† partir do original, mas o mesmo n√£o pode ser modificado

                permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

                permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos




        ----------
        Dicion√°rios (dict)
            
            Estrutura que associa uma chave a um determinado valor. √â a representa√ß√£o do t√£o famoso objeto que utilizamos em JavaScript.

                people_by_id = {1: "Maria", 2: "Fernanda", 3: "Felipe"}  # elementos no formato "chave: valor" separados por v√≠rgula, envolvidos por chaves

                people_by_name = {"Maria": 1, "Fernanda": 2, "Felipe": 3}  # outro exemplo, dessa vez usando strings como chaves. As aspas s√£o necess√°rias para que o Python n√£o ache que `Maria`, `Fernanda` e `Felipe` sejam vari√°veis.

                # elementos s√£o acessados por suas chaves
                people_by_id[1]  # sa√≠da: Maria

                # elementos podem ser removidos com a palavra chave del
                del people_by_id[1]
                people_by_id.items()  # dict_items([(1, "Maria"), (2, "Fernanda"), (3, "Felipe")])
                # um conjunto √© retornado com tuplas contendo chaves e valores




        -------------
        Range (range)

            Estrutura capaz de gerar uma sequ√™ncia num√©rica de um valor inicial at√© um valor final, modificando seu valor de acordo com o passo (step) definido. Pode ser declarado como range( [start], stop[, step] ), em que start e step podem ser omitidos, possuindo valores iniciais iguais a 0 e 1 respectivamente.

            Anota a√≠ ‚úèÔ∏è: O stop n√£o √© inclu√≠do na sequ√™ncia, portanto, caso queira uma sequ√™ncia de 1 at√© 10 a chamada dever√° ser range(1, 11)

            Seus valores s√£o criados √† medida que esta sequ√™ncia √© percorrida.


                    # vamos converter o range em uma lista para ajudar na visualiza√ß√£o

                    # definimos somente o valor de parada
                    list(range(5))  # sa√≠da: [0, 1, 2, 3, 4]

                    # definimos o valor inicial e o de parada
                    list(range(1, 6))  # sa√≠da: [1, 2, 3, 4, 5]

                    # definimos valor inicial, de parada e modificamos o passo para 2
                    list(range(1, 11, 2))  # sa√≠da: [1, 3, 5, 7, 9]

                    # podemos utilizar valores negativos para as entradas tamb√©m
                    list(range(10, 0, -1))  # sa√≠da: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
                


            Al√©m dos tipos b√°sicos, temos outros como datas, tuplas nomeadas, arrays, enumera√ß√µes e outros, mas estes t√™m de ser importados de seus respectivos m√≥dulos.






    ---------------------------------------------------------------------------------------------------------
    Estruturas condicionais
    
        Vamos imaginar a seguinte situa√ß√£o: em uma an√°lise de dados sobre pessoas desenvolvedoras, temos uma base de dados que cont√©m o sal√°rio delas, mas n√£o mostra a informa√ß√£o sobre sua senioridade.

        Para fazer um agrupamento por essa classifica√ß√£o de n√≠vel de experi√™ncia, precisamos criar uma nova coluna que ser√° baseada no sal√°rio:

            Menor que R$2.000,00, pessoa desenvolvedora estagi√°ria;

            Entre R$2.000,00 e R$5.800,00, pessoa desenvolvedora j√∫nior;

            Entre R$5.800,00 e R$7.500,00, pessoa desenvolvedora pleno;

            Entre R$7.500,00 e R$10.500,00, pessoa desenvolvedora s√™nior;

            Qualquer valor acima do que j√° foi mencionado a pessoa desenvolvedora √© considerada lideran√ßa.

            
        R:

            position = ""
            if salary <= 2000:
                position = "estagi√°rio"
            elif 2000 < salary <= 5800:
                position = "j√∫nior"
            elif 5800 < salary <= 7500:
                position = "pleno"
            elif 7500 < salary <= 10500:
                position = "senior"
            else:
                position = "l√≠der"


        Anota a√≠ ‚úèÔ∏è: A indenta√ß√£o do c√≥digo deve ser feita com 4 espa√ßos em vez de tabs.

        Note que if e elif s√£o seguidos de uma express√£o que se avaliada como verdadeira, o trecho de c√≥digo ser√° executado. Um outro detalhe √© a aus√™ncia de chaves para definir o bloco. Utilizamos o caractere : para indicar abertura de um bloco e somente indenta√ß√£o para indicar o t√©rmino.
    
        Agora que escrevemos mais linhas, notamos tamb√©m a aus√™ncia do caractere ;. Pois bem, a filosofia da linguagem Python nos diz: ‚ÄúLegibilidade conta‚Ä¶‚Äù, ent√£o, com isso, n√£o precisamos mais desse caractere.

        Com a senioridade em m√£os, podemos criar uma nova coluna em nossa base dados com essa informa√ß√£o e realizar o agrupamento por cargo, desenhando lindos gr√°ficos.

        Voc√™ pode estar se perguntando: ‚ÄúPosso modificar para uma estrutura switch?‚Äù Resposta: A estrutura condicional if e seu aninhamento com elif e else √© t√£o simples e leg√≠vel que n√£o precisamos da estrutura switch.


        Em alguns casos, em que n√£o seja prejudicada a legibilidade, podemos criar estruturas de mapeamento (dicts) para simplificar o aninhamento de condicionais. Como o exemplo a seguir:


                key = "id"
                from_to = {
                    "id": "identifier",
                    "mail": "email",
                    "lastName": "last_name",
                }
                from_to[key]





    --------------------------------------------------------------------------------------------------------
    Estruturas de repeti√ß√£o

        for
    
            Imagine um sistema que fa√ßa a listagem de restaurantes. Estes restaurantes possuem uma nota proveniente da avalia√ß√£o dos seus clientes.

                    restaurants = [
                        {"name": "Restaurante A", "nota": 4.5},
                        {"name": "Restaurante B", "nota": 3.0},
                        {"name": "Restaurante C", "nota": 4.2},
                        {"name": "Restaurante D", "nota": 2.3},
                    ]



            Quando um cliente pede a listagem de restaurantes, ele pode escolher filtrar o resultado de acordo com a nota. Essa filtragem pode ocorrer percorrendo a lista de restaurantes ou criando uma nova lista com somente aqueles que atendem ao filtro, assim como mostra o exemplo abaixo:

                    filtered_restaurants = []
                    min_rating = 3.0
                    for restaurant in restaurants:
                        if restaurant["nota"] > min_rating:
                            filtered_restaurants.append(restaurant)
                    print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D
        


            Dado que a maior parte do tempo estamos percorrendo estruturas, os criadores do Python decidiram que o for each seria o la√ßo de repeti√ß√£o principal na linguagem.

            Para cada repeti√ß√£o do nosso la√ßo, um novo elemento da estrutura iter√°vel √© atribu√≠do a vari√°vel de itera√ß√£o. No exemplo acima, vemos que a cada itera√ß√£o um novo restaurante √© colocado na vari√°vel restaurant.

            Anota ai ‚úèÔ∏è: Em alguns casos, podemos ainda querer percorrer uma sequ√™ncia num√©rica, e para isto iteramos sobre a estrutura de dados range.

                    for index in range(5):
                    print(index)

            Al√©m de listas, v√°rias outras estruturas s√£o iter√°veis, como strings (str), tuplas (tuple), conjuntos (set), dicion√°rios (dict) e at√© mesmo arquivos.



        ---------
        Compreens√£o de lista (list comprehension) - (√â RECOMENDADO USAR. DIMINUIR√Å O TAMANHO DO C√ìDIGO)

            A compreens√£o de listas em Python possui uma sintaxe f√°cil e compacta para cria√ß√£o de listas, seja a partir de uma string ou de outra lista. √â uma maneira concisa de cria√ß√£o que executa uma opera√ß√£o em cada item da lista j√° existente.

            Quando uma nova lista √© criada como resultado de uma itera√ß√£o, podemos simplificar utilizando compreens√£o de listas.

                    min_rating = 3.0
                    filtered_restaurants = [restaurant
                                             for restaurant in restaurants
                                             if restaurant["nota"] > min_rating]
                    print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D


            A compreens√£o de listas √© declarada da mesma maneira que uma lista comum, por√©m no lugar dos elementos n√≥s colocamos a itera√ß√£o que vai gerar os elementos da nova lista.

            De olho na dicaüëÄ: √â poss√≠vel filtrar esses elementos utilizando o if.

            Poder√≠amos listar tamb√©m somente o nome dos restaurantes, veja o exemplo abaixo:

                    # min_rating = 3.0
                    filtered_restaurants = [restaurant["name"]  # aqui pedimos somente o nome do restaurante
                    #                        for restaurant in restaurants
                    #                        if restaurant["nota"] > min_rating]
                    # print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D


            A compreens√£o de listas tamb√©m funciona com listas de strings. A seguinte cria uma nova lista de strings com os nomes que cont√©m a letra ‚Äòa‚Äô.

                    names_list = ['Duda', 'Rafa', 'Cris', 'Yuri']
                    new_names_list = [name for name in names_list if 'a' in name]

                    # Aqui o for percorre cada nome em "names_list", verifica se existe a letra "a" nele,
                    # o adiciona √† vari√°vel "name", e ent√£o gera nossa nova lista "new_names_list"
                    print(new_names_list)

                    # Sa√≠da
                    ['Duda', 'Rafa']


            O exemplo a seguir usa uma compreens√£o de listas para criar uma lista com o quadrado dos n√∫meros entre 1 e 10.

                    quadrados = [x*x for x in range(11)]
                    print(quadrados)

                    # Sa√≠da
                    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


            Isto √© equivalente √†s opera√ß√µes de map e filter em JavaScript.






    ------------
    while
            
        A Sequ√™ncia de Fibonacci, muito presente em diversas formas na natureza, √© uma sequ√™ncia num√©rica come√ßando por 0 e 1 e cada termo subsequente corresponde √† soma dos dois anteriores. Podemos escrever esta sequ√™ncia da seguinte maneira:
        
            n = 10
            last, next = 0, 1
            while last < n:
                print(last)
                last, next = next, last + next


            O la√ßo de repeti√ß√£o while acontecer√° enquanto a condi√ß√£o for satisfeita.

            No exemplo anterior, estamos imprimindo os elementos da sequ√™ncia at√© que atinja o valor 10. Neste caso, foi utilizado um truque chamado atribui√ß√£o m√∫ltipla. Isto √©, atribui√ß√£o de v√°rios valores a m√∫ltiplas vari√°veis ao mesmo tempo.
        
            De olho na dicaüëÄ: Este truque pode ser utilizado tamb√©m para fazer a troca de valores entre vari√°veis: a, b = b, a.




    ----------
    enumerate

        Em Python, um loop for geralmente √© escrito como um loop sobre um objeto iter√°vel. Isso significa que voc√™ n√£o precisa de uma vari√°vel de contagem para acessar itens no iter√°vel.

        Por√©m, √†s vezes, pode acontecer de voc√™ querer uma vari√°vel que muda em cada itera√ß√£o do loop. Em vez de criar e incrementar uma vari√°vel voc√™ mesmo, voc√™ pode usar enumerate() do Python para obter um contador e o valor do iter√°vel ao mesmo tempo:

           
                languages = ['Python', 'Java', 'JavaScript']

                enumerate_prime = enumerate(languages)

                # converte um objeto enumerate em uma lista
                print(list(enumerate_prime))

                # Sa√≠da: [(0, 'Python'), (1, 'Java'), (2, 'JavaScript')]

            


        Voc√™ tamb√©m pode desestruturar (unpack) os itens da lista ou tupla:

                languages = ['Python', 'Java', 'JavaScript']

                for index, language in enumerate(['Python', 'Java']):
                    print(f'{index} - {language}')
                # Sa√≠da:
                0 - Python
                1 - Java






    ---------------------------------------------------------------------------------------------------------
    Fun√ß√µes

         Fun√ß√µes s√£o definidas atrav√©s da palavra reservada def, seguida por um nome e os par√¢metros entre par√™nteses. Como todo bloco de c√≥digo em Python, o caractere : define o in√≠cio do bloco, e a indenta√ß√£o define seu fim.

        Os par√¢metros podem ser passados de forma:

            -> posicional: s√£o aqueles definidos por meio da posi√ß√£o em que cada um √© passado;
            -> nomeada: s√£o definidos por meio de seus nomes.

    

        exemplos: 

            def soma(x, y):
                return x + y

            soma(2, 2)  # os par√¢metros aqui s√£o posicionais

            soma(x=2, y=2)  # aqui estamos nomeando os par√¢metros



        Os par√¢metros tamb√©m podem ser vari√°dicos, ou seja, variam em sua quantidade.

        Anota a√≠ ‚úèÔ∏è: Par√¢metros posicionais vari√°dicos s√£o acessados como uma tupla no interior de uma fun√ß√£o, e par√¢metros nomeados vari√°dicos como um dicion√°rio.



                def concat(*strings):
                    # Equivalente a um ", ".join(strings), que concatena os elementos de um iter√°vel em uma string utilizando um separador
                    # Nesse caso a string resultante estaria separada por v√≠rgula
                    final_string = ""
                    for string in strings:
                        final_string += string
                        if not string == strings[-1]:
                            final_string += ', '
                    return final_string

                # pode ser chamado com 2 par√¢metros
                concat("Carlos", "Cristina")  # sa√≠da: "Carlos, Cristina"

                # pode ser chamado com um n√∫mero n de par√¢metros
                concat("Carlos", "Cristina", "Maria")  # sa√≠da: "Carlos, Cristina, Maria"

                // LEMBRANDO: dict √© igual ao objeto usado em js

                # dict √© uma fun√ß√£o que j√° vem embutida no python
                dict(nome="Felipe", sobrenome="Silva", idade=25)  # cria um dicion√°rio utilizando as chaves passadas

                dict(nome="Ana", sobrenome="Souza", idade=21, turma=1)  # o n√∫mero de par√¢metros passados para a fun√ß√£o pode variar


        
        ----

        As vari√°veis definidas dentro das fun√ß√µes tem escopo local. Por√©m, quando uma fun√ß√£o n√£o encontra um nome no escopo local, ela ir√° procurar no espa√ßo de nomes global.

        Em alguns casos, podemos querer limitar um par√¢metro em nomeado ou posicional para evitar ambiguidades e/ou aumentar legibilidade.
        
                len([1, 2, 3, 4])  # fun√ß√£o len n√£o aceita argumentos nomeados

                len(obj=[1, 2, 3, 4])  # este c√≥digo ir√° falhar

                print("Coin", "Rodrigo", ", ")  # imprime Coin Rodrigo ,

                print("Coin", "Rodrigo", sep=", ")  # nomeando o terceiro par√¢metro, agora temos a sa√≠da: Coin, Rodrigo



    ------------------------------------------------------------------------------------------------------
    Extras

        Pip
            O que √©?

            Pip √© o gerenciador de pacotes do python. √â um cliente de linha de comandos utilizado para controle das depend√™ncias do projeto.

            Para que serve?

                Utilizaremos o pip para controlar a vers√£o das bibliotecas utilizadas para desenvolvimento do sistema. O pip nos permite baixar uma vers√£o espec√≠fica de uma biblioteca como por exemplo python3 -m pip install fastapi==0.43.0.

            Como instalar

                Esta ferramenta n√£o vem por padr√£o no sistema operacional Ubuntu e pode ser instalada utilizando o comando sudo apt install python3-pip.

            Vamos verificar se deu tudo certo?

                Abra um terminal e digite python3 -m pip --version.

                python3 -m pip --version


                A sa√≠da dever√° ser similar a apresentada abaixo:

                pip 19.2.3 from /usr/lib/python3.8/site-packages (python 3.8)



        -----
        Flake8

            O que √©?

                Flake8 √© um programa de linha de comando que verifica seu c√≥digo e busca por erros ou formata√ß√µes que n√£o seguem o guia de estilo padr√£o do python, conhecido como PEP-8. Al√©m disso tamb√©m verifica a complexidade ciclam√°tica do seu c√≥digo.

            Para que serve?

                √â muito comum cometermos alguns erros de sintaxe, principalmente quando ainda estamos nos familiarizando com uma linguagem nova. Assim como durante o nosso dia a dia podemos esquecer algum c√≥digo n√£o utilizado. Esta ferramenta vai analisar o seu c√≥digo e procurar poss√≠veis erros, evitando assim que s√≥ ocorram no momento em que o c√≥digo for executado.

                Esta ferramenta tamb√©m aponta poss√≠veis linhas que n√£o est√£o seguindo o estilo de c√≥digo definido para a linguagem python.

                Outra coisa bem comum quando estamos escrevendo c√≥digo √© que uma parte dele come√ßa a se tornar t√£o complexa que h√° n caminhos por onde seu algoritmo pode seguir. Normalmente isto indica que devemos modificar o c√≥digo para torn√°-lo mais simples e leg√≠vel. O Flake8 ir√° apontar qual parte do seu c√≥digo est√° complexa e que deve ser modificada.

                Esta ferramenta ser√° integrada ao editor, dessa maneira, ao salvar o arquivo, teremos os erros encontrados apontados diretamente no mesmo.

            Como instalar

                O pacote flake8 pode ser instalado utilizando utilizando a ferramenta pip vista anteriormente. Vamos utilizar sudo neste caso para garantir que ela esteja dispon√≠vel para todos os usu√°rios do sistema operacional. Digite o comando abaixo:

                    sudo python3 -m pip install flake8


            Vamos verificar se deu tudo certo?

                    python3 -m flake8 --version


        
        -------
        Black

            O que √©?

                Black √© o formatador de c√≥digo Python intransigente. Ao us√°-lo, voc√™ concorda em ceder o controle sobre as min√∫cias da formata√ß√£o manual. Em troca, o black d√° a voc√™ velocidade, determinismo e liberdade do irritante pycodestyle sobre formata√ß√£o. Voc√™ economizar√° tempo e energia mental para assuntos mais importantes.

            Para que serve?

                O black √© um formatador autom√°tico de c√≥digo, ele ir√° modificar o seu c√≥digo seguindo o guia de estilo do Python. Iremos configur√°-lo junto ao nosso editor para que a formata√ß√£o seja feita atrav√©s de um atalho do teclado como shift + ctrl + i.

            Como instalar

                O pacote black pode ser instalado utilizando utilizando a ferramenta pip vista anteriormente. Vamos utilizar sudo neste caso para garantir que ela esteja dispon√≠vel para todos os usu√°rios do sistema operacional. Digite o comando abaixo:

                    sudo python3 -m pip install black


            Vamos verificar se deu tudo certo?

                    python3 -m black --version



        --------
        
        VSCode(Python) (estou usando o plugin, mas n√£o a config, pois parece que o prettier j√° conserta tudo pra mim)
        
            Para que serve?

                O plugin de Python para VSCode fornece auto-complete, integra√ß√£o com os linters vistos anteriormente, tamb√©m √© uma ferramenta para depura√ß√£o de c√≥dig

            Como instalar

                Abra o VS Code Quick Open (Ctrl+P), cole o comando a seguir e pressione enter.

                    ext install ms-python.python


                Ap√≥s instalar a extens√£o, digite ctrl + shift + p, v√° em Preferences: Open Settings (JSON) e acrescente as seguintes configura√ß√µes.

                    // ...
                        "python.linting.enabled": true,
                        "python.linting.flake8Enabled": true,
                        "python.formatting.blackArgs": [
                            "-l 79"
                        ],
                        "python.formatting.provider": "black",
                    // ...



            Vamos verificar se deu tudo certo?

                Abra um arquivo com extens√£o .py no VSCode e digite o c√≥digo lista = [1,2,3]. Salve o arquivo e um aviso de erro deve acontecer.

                Passando o mouse sobre a linha veremos que o erro √©: missing whitespace after ','flake8(E231).

                Para corrigir e testar se o nosso formatador est√° funcionando corretamente, digite ctrl + shift + i. Ap√≥s salvar novamente o erro deve ter desaparecido. Caso isto n√£o aconte√ßa certifique que tenha feitos os passos anteriormente para instala√ß√£o do flake8 e black.



   
        ------------------
        CodeRunner
            O que √©?

                Extens√£o do VSCode que permite rodar c√≥digos ou trechos de c√≥digos em mais de 30 linguagens de programa√ß√£o e adicionar tamb√©m comandos customizados.

            Para que serve?

                Rodar trechos de c√≥digos ou o c√≥digo inteiro sem sair do VSCode.

            Como instalar

                Abra o VS Code Quick Open (Ctrl+P), cole o comando a seguir e pressione enter.
            
                    ext install formulahendry.code-runner


                Ap√≥s instalar a extens√£o, digite ctrl + shift + p, v√° em Preferences: Open Settings (JSON) e acrescente as seguintes configura√ß√µes.
            
                    // ...

                        "code-runner.executorMap": {
                            "python": "python3 -u"
                        },
                        "code-runner.runInTerminal": true,

                    // ...

                Esta configura√ß√£o garante que nosso script ser√° executado utilizando a vers√£o 3 do Python.


            Vamos verificar se deu tudo certo?

            Escreva um pequeno c√≥digo como print("Ol√° Mundo") e apertando ctrl + alt + N o c√≥digo ser√° executado.

    


    --------------------------------------------------------------------------------------------------------
    Escrevendo os primeiros arquivos

        At√© aqui, programamos utilizando o terminal interativo e t√≠nhamos uma resposta logo em seguida. Mas, se fecharmos o terminal vamos perder tudo que fizemos at√© agora, al√©m disso programas do dia a dia n√£o funcionam assim.       
    
        Antes de escrever nosso primeiro arquivo, precisamos saber que todo arquivo com extens√£o .py √© considerado um m√≥dulo.

        M√≥dulos s√£o declarados utilizando snake case, ou seja, com nomes min√∫sculos e quando possu√≠rem mais de uma palavra, devem ser separadas por underscore (_).


        Vamos agora criar o arquivo area.py, declarando fun√ß√µes que calculam a √°rea de algumas figuras geom√©tricas.

                // area.py


                PI = 3.14  # PI √© uma "constante" em nosso m√≥dulo


                def square(side):
                    '''Calculate area of square.'''
                    return side * side


                def rectangle(length, width):
                    '''Calculate area of rectangle.'''
                    return length * width


                def circle(radius):
                    '''Calculate area of circle.'''
                    return PI * radius * radius




        Observe que esse c√≥digo segue algumas boas pr√°ticas para legibilidade, tais como:

            -> Entre cada fun√ß√£o temos um espa√ßo de 2 linhas;

            -> As fun√ß√µes s√£o declaradas com nomes em letras min√∫sculas;

            -> A constante PI √© definida em letras mai√∫sculas.


        Aviso: Existe uma conven√ß√£o de declarar valores considerados constantes com letras mai√∫sculas, e o respeito por outros programadores de n√£o alterarem aquele valor.

        Abra um terminal e para executar o m√≥dulo em python, escreva python3 area.py. Se n√£o houve nenhum erro de digita√ß√£o, nada deve ter acontecido. Neste m√≥dulo s√≥ temos defini√ß√µes das fun√ß√µes e valores, mas n√£o estamos executando nenhuma delas. Isto √© o que chamamos de execu√ß√£o do m√≥dulo como script.

        Hora de test√°-lo! No fim do arquivo, vamos adicionar algumas linhas para imprimir a √°rea de algumas figuras geom√©tricas.

            print("√Årea do quadrado:", square(10))
            print("√Årea do ret√¢ngulo:", rectangle(2, 2))
            print("√Årea do c√≠rculo:", circle(3))


        Agora, quando executamos o arquivo area.py, estes valores de teste s√£o exibidos



        ----
        Vamos utilizar o nosso m√≥dulo de calcular √°rea de figuras planas. Escreva um novo arquivo com nome people.py e ele ser√° um script para calcular pessoas que est√£o presentes em um show, dado a √°rea do mesmo. Este script ser√° escrito da seguinte maneira:

                // people.py

                import area


                PEOPLE_PER_SQUARE_METER = 2  # numero de pessoas por metro quadrado em m√©dia
                FIELD_LENGTH = 60  # em metros
                FIELD_WIDTH = 45  # em metros
                people_at_concert = (
                    area.rectangle(FIELD_LENGTH, FIELD_WIDTH) * PEOPLE_PER_SQUARE_METER
                )
                print("Est√£o presentes no show aproximadamente", people_at_concert, "pessoas.")



        Anota a√≠ ‚úèÔ∏è: O import √© utilizado para termos todas as fun√ß√µes do m√≥dulo dispon√≠veis em outro arquivo. Uma outra maneira de utilizarmos √© escrevendo from area import rectangle, por exemplo, se quisermos importar apenas rectangle a partir de area. Por√©m, tome cuidado com conflitos de nomes caso use essa segunda maneira.

        Os nossos valores de teste est√£o sendo exibidos quando importamos o m√≥dulo. Mas n√£o queremos que isso aconte√ßa.

        Para corrigir, podemos acrescentar uma condicional ao m√≥dulo para somente exibir esses valores de teste quando o m√≥dulo for executado como script.

        A vari√°vel __name__ √© utilizada pelo interpretador Python para identificar o arquivo que esta sendo executado e seu valor ser√° "__main__" quando invocamos um m√≥dulo como script.








-------------------------------------------------------------------------------------------------------------
DIA 02: ENTRADA E SA√çDA DE DADOS

    Estruturando uma aplica√ß√£o

        M√≥dulos

            Um m√≥dulo √© um arquivo que cont√©m defini√ß√µes e instru√ß√µes em Python. O nome do arquivo √© um nome acrescido de .py. Voc√™ pode importar um m√≥dulo dentro de um outro arquivo Python e ter acesso √†s suas fun√ß√µes, classes, etc.
            
            ‚ùóÔ∏èEm linhas gerais, todo arquivo que √© escrito com a linguagem Python e com a extens√£o .py √© considerado um m√≥dulo.


            Observe o arquivo my_math.py abaixo:

                    def sum(a, b):
                      return a + b


                    def pot(a, b):
                      return a ** b


                    print(sum(2, 2))
                    print(pot(2, 3))



            Este arquivo √© um m√≥dulo Python, que pode ser executado como script com o comando python3 my_math.py. Se isso ocorrer, os retornos ser√£o 4 e 8, respectivamente, devido √†s chamadas das fun√ß√µes dentro dos m√©todos print().
        
            Entretanto, as fun√ß√µes que criamos neste arquivo podem ser reaproveitadas por outros m√≥dulos atrav√©s da declara√ß√£o import.

            √Ä medida que fomos avan√ßando, esses conceitos ficar√£o cada vez mais n√≠tidos.




        ------------
        Pacotes

            Pacotes s√£o m√≥dulos Python que cont√™m outros m√≥dulos e/ou pacotes, comumente separados por responsabilidades similares. Na pr√°tica, um pacote √© um diret√≥rio que pode conter v√°rios m√≥dulos (arquivos de extens√£o .py) e/ou outros pacotes.

            Exemplo de tipos diferentes de imports de pacotes:

                    import http  # importa o pacote http como um m√≥dulo

                    from http import client  # importa o m√≥dulo client do pacote http

                    from http.client import HTTP_PORT  # importa a constante HTTP_POST do m√≥dulo client do pacote http



        
        -----------
        Ambiente Virtual
        
            Imagine que, em uma m√°quina, h√° um projeto Python que cont√©m alguns pacotes de terceiros instalados e, dentre eles, h√° uma biblioteca na vers√£o 1.4. Imagine tamb√©m que, na mesma m√°quina, √© iniciado um novo projeto que precisa da mesma biblioteca, mas dessa vez na vers√£o 2.0. O que fazer? As vers√µes s√£o compat√≠veis? Se eu atualizar o sistema, a vers√£o antiga vai continuar funcionando?

            O venv entra como resposta para essas perguntas! Ele √© um m√≥dulo j√° embutido na linguagem, e serve para isolar ambientes de projetos. Ou seja, eu consigo ter dois projetos rodando em dois ambientes diferentes, que podem ter vers√µes diferentes de uma mesma biblioteca.

            Na pr√°tica, vamos instalar as bibliotecas em um diret√≥rio que est√° relacionado ao projeto. Assim, cada projeto pode ter suas pr√≥prias bibliotecas na vers√£o que quiser. ‚ùóÔ∏èA ideia √© a mesma do npm que voc√™s j√° v√™m usando.

            O comando para cria√ß√£o deste ambiente isolado √©:
    
                    python3 -m venv .venv


            sendo que .venv √© o nome do ambiente isolado. Este comando deve ser executado na raiz do projeto.

            üí° Caso o venv n√£o esteja instalado, utilize o comando sudo apt install python3-venv.

            Este ambiente isolado ser√° visto como um diret√≥rio criado na raiz do projeto. O ponto na frente do nome faz com que o diret√≥rio fique oculto.

            Depois de criado, temos que ativar este ambiente para us√°-lo. Isto √© importante pois sempre que decidirmos trabalhar neste projeto devemos repetir este passo:

                    source .venv/bin/activate

            
            Voc√™ pode conferir se o comando de ativa√ß√£o do ambiente virtual deu certo com o seguinte comando:

                    which python3


            O resultado ser√° o caminho para a pasta onde voc√™ criou seu ambiente virtual (pwd), acrescido de .venv/bin/python3.

            Pronto! Agora nosso ambiente est√° preparado para a instala√ß√£o das bibliotecas que precisaremos nos nossos projetos.






    -------------------------------------------------------------------------------------------
    Entrada e Sa√≠da

        Fun√ß√µes podem receber argumentos das pessoas que usam o programa, process√°-los e retornar algum valor. Mas como estes argumentos chegam a elas? E o resultado do nosso processamento, como exibi-lo para a pessoa utilizando nossa aplica√ß√£o?

        De modo geral, podemos dizer que um programa seria menos √∫til se n√£o pud√©ssemos coletar valores de pessoas usu√°rias, e muito menos agrad√°vel de se utilizar caso o resultado apresentado fosse pouco leg√≠vel.
        
        Existem algumas maneiras de nos comunicarmos com o exterior do programa em Python para receber dados, assim como existem maneiras de melhorar a exibi√ß√£o dos nossos resultados.


        -----
        Entrada
        
            Uma das maneiras que existem de receber valores em nossos programas √© atrav√©s da fun√ß√£o input, que vem embutida na pr√≥pria linguagem. Esta fun√ß√£o est√° vinculada √† entrada padr√£o do sistema operacional e tem como par√¢metro opcional o prompt que, caso seja fornecido, exibir√° a mensagem passada para ele em tela. O valor recebido atrav√©s da fun√ß√£o ser√° do tipo texto (str):

                    input("Digite uma mensagem:")



            O programa permanece parado at√© que algum dado seja fornecido. Isto pode ser feito digitando algum conte√∫do, teclando Enter, ou podemos tamb√©m ter os dados redirecionados de um arquivo ou outra fonte. Veja um exemplo de um programa com entrada de dados fornecido pela pessoa usu√°ria:


                    import random

                    random_number = random.randint(1, 10)  # escolhe um n√∫mero aleat√≥rio entre 1 e 10
                    guess = ""

                    while guess != random_number:  # enquanto n√£o adivinhar o n√∫mero
                        guess = int(input("Qual o seu palpite? "))  # pergunte a pessoa usu√°ria um n√∫mero

                    print("O n√∫mero sorteado era: ", guess)
        

            üí° Fazemos uma convers√£o do palpite para um n√∫mero inteiro, pois entrada de dados √© sempre str.
        
            üí° Para rodar o exemplo acima, n√£o crie um arquivo chamado random para inserir o c√≥digo, pois o m√≥dulo que estamos importando se chama random e isso pode causar um erro! Lembre-se que, para rodar o c√≥digo, voc√™ deve executar o comando python3 nome_do_arquivo.py no terminal.


            Outra maneira de recebermos valores externos na execu√ß√£o de nossos programas √© utilizando o m√≥dulo sys. Quando executamos um script e adicionamos par√¢metros, os mesmos estar√£o dispon√≠veis atrav√©s de uma vari√°vel chamada sys.argv, que √© preenchida sem que precisemos fazer nada. Na pr√°tica, podemos escrever o conte√∫do abaixo em um arquivo e passar alguns par√¢metros ao execut√°-lo:


            import sys


            if __name__ == "__main__":
                for argument in sys.argv:
                    print("Received -> ", argument)




            OBS: esse artigo da alura pode ajudar a entender: https://www.alura.com.br/artigos/o-que-significa-if-name-main-no-python



            Podemos executar o c√≥digo usando os par√¢metros atrav√©s do comando abaixo:

                    python3 arquivo.py 2 4 "teste"



            A sa√≠da ser√°:

                    Received ->  arquivo.py
                    Received ->  2
                    Received ->  4
                    Received ->  teste




        --------
        Sa√≠da

            Como j√° visto, a fun√ß√£o print ‚Äî que j√° vem embutida na linguagem ‚Äî √© a principal fun√ß√£o para imprimirmos um valor em ‚Äútela‚Äù. Normalmente esta fun√ß√£o escreve na sa√≠da padr√£o do sistema operacional, mas veremos que √© poss√≠vel modificar este e outros comportamentos.
            
            Esta fun√ß√£o recebe par√¢metros de forma vari√°vel, ou seja, pode receber nenhum, um, dois ou n par√¢metros durante sua invoca√ß√£o.

                    print("O resultado √©", 42)  # sa√≠da: O resultado √© 42

                    print("Os resultados s√£o", 6, 23, 42)  # sa√≠da: Os resultados s√£o 6 23 42

            

            O separador padr√£o dos argumentos √© um espa√ßo em branco, que pode ser alterado.

                    print("Maria", "Jo√£o", "Miguel", "Ana")  # sa√≠da: Maria Jo√£o Miguel Ana

                    print("Maria", "Jo√£o", "Miguel", "Ana", sep=", ")  # sa√≠da: Maria, Jo√£o, Miguel, Ana



            Al√©m do separador, podemos tamb√©m alterar o caractere de fim de linha que, por regra, √© uma quebra de linha:
    
                PADR√ÉO (A sa√≠da ser√° impressa em duas linhas):
            
                    print("Em duas ")
                    print("linhas.")


                ALTERANDO O PADR√ÉO (A sa√≠da ser√°: "Na mesma linha.") :

                    print("Na mesma", end=" ")
                    print("linha.")



            J√° sabemos que erros podem acontecer e o sistema operacional normalmente espera que um programa escreva seus erros na sa√≠da de erros.

            Existe um par√¢metro que nos permite modificar a sa√≠da padr√£o para a sa√≠da de erros:

                    import sys


                    err = "Arquivo n√£o encontrado"
                    print(f"Erro aconteceu: {err}", file=sys.stderr)



            üí° Em Python, podemos fazer interpola√ß√£o de vari√°veis e express√µes utilizando f-string. Adicionamos um f antes das aspas e o valor de sa√≠da entre chaves. Essa dica √© importante, pois √© a maneira mais eficiente de formatar strings.


                    x = 5
                    y = 3
                    print(f"{x} / {y} = {x / y:.2f}")  # sa√≠da: 5 / 3 = 1.67
                    # {x} √© substitu√≠do por 5
                    # {y} √© substitu√≠do por 3
                    # {x / y:.2f} O que vem ap√≥s os dois pontos s√£o formatadores, como nesse exemplo, duas casas decimais (.2f).
                    print(f"{x:.^3}")  # sa√≠da: ".5."
                    # . √© o caractere utilizado para preencher
                    # ^ indica que o valor ser√° centralizado
                    # 3 s√£o o n√∫mero de caracteres exibidos






    --------------------------------------------------------------------------------------------------------
    Desempacotamento de Valores

        O desempacotamento de valores √© um recurso muito √∫til de Python quando queremos separar os valores recebidos em vari√°veis diferentes. Quando h√° uma atribui√ß√£o m√∫ltipla e o valor da direita pode ser percorrido, o Python entende que deve atribuir cada um dos valores a uma vari√°vel da esquerda, seguindo a ordem. Vejamos no exemplo abaixo:

                
                    a, b = "cd"
                    print(a)  # sa√≠da: c
                    print(b)  # sa√≠da: d

                    head, *tail = (1, 2, 3) # Quando um * est√° presente no desempacotamento, os valores s√£o desempacotados em formato de lista.
                    print(head)  # sa√≠da: 1
                    print(tail)  # sa√≠da: [2, 3]





    ---------------------------------------------------------------------------------------------------------
    Manipula√ß√£o de arquivos

        Seja para armazenar alguma informa√ß√£o processada, para manipular imagens, √°udios, v√≠deos ou recuperar dados de uma planilha, precisamos manipular arquivos.

        Podemos fazer uma opera√ß√£o de leitura, de escrita ou at√© de ambas, a depender da nossa necessidade. Por√©m, independentemente da opera√ß√£o executada, √© preciso sempre fechar o arquivo ap√≥s oper√°-lo.


        A fun√ß√£o open √© a respons√°vel por abrir um arquivo, tornando poss√≠vel sua manipula√ß√£o. Seu √∫nico par√¢metro obrigat√≥rio √© o nome do arquivo. Por padr√£o, arquivos s√£o abertos somente para leitura, mas podemos modificar isto passando o modo com que vamos abrir o arquivo. No exemplo abaixo, estamos utilizando mode="w", ou seja, estamos abrindo o arquivo para escrita:


                file = open("arquivo.txt", mode="w")  # ao abrir um arquivo para escrita, um novo arquivo √© criado mesmo que ele j√° exista, sobrescrevendo o antigo.




        Para escrevermos um conte√∫do em um arquivo utilizamos a fun√ß√£o write:
        
                # file = open("arquivo.txt", mode="w")

                file.write("nome idade\n")
                file.write("Maria 45\n")
                file.write("Miguel 33\n")



        üí° S√≥ √© poss√≠vel escrever em um arquivo ap√≥s abri-lo em um modo que permita escrita.


        Assim como podemos redirecionar a sa√≠da do nosso programa para a sa√≠da de erros, podemos redirecionar o conte√∫do digitado dentro de print para um arquivo. Ou seja, tamb√©m podemos escrever em um arquivo atrav√©s do print.

                #
                # file.write("Miguel 33\n")


                # N√£o precisa da quebra de linha, pois esse √© um comportamento padr√£o do print
                print("T√∫lio 22", file=file)



        Para escrever m√∫ltiplas linhas podemos utilizar a fun√ß√£o writelines. Repare que a fun√ß√£o espera que cada linha tenha seu pr√≥prio caractere de separa√ß√£o (\n):

                #
                # print("T√∫lio 22", file=file)


                LINES = ["Alberto 35\n", "Betina 22\n", "Jo√£o 42\n", "Victor 19\n"]
                file.writelines(LINES)
            


        Abrimos o arquivo e escrevemos seu conte√∫do. Vamos ent√£o fech√°-lo:

                # file.writelines(LINES)


                file.close()


        
        Mas por que devemos sempre fechar um arquivo? A resposta vem do sistema operacional: temos uma quantidade limite de arquivos que podemos abrir de uma s√≥ vez e um erro √© retornado quando atingimos esse limite. Vamos ver um c√≥digo para demonstrar a ocorr√™ncia de um erro ao abrir muitos arquivos ao mesmo tempo:

                arquivos = []
                for index in range(10240):
                    arquivos.append(open(f"arquivo{index}.txt", "w"))



        O n√∫mero que o programa ir√° falhar pode variar, pois o sistema operacional mant√©m alguns arquivos abertos para seu pr√≥prio uso.

        Outro motivo importante para se fechar os arquivos √© que normalmente a manipula√ß√£o de arquivos √© feita atrav√©s de buffers. Ou seja, a escrita em disco pode n√£o ser imediata. Quando fechamos o arquivo, garantimos que tudo aquilo que ainda n√£o est√° escrito seja persistido.

        A leitura do conte√∫do de um arquivo pode ser feita utilizando a fun√ß√£o read. Para experimentar, vamos escrever em um arquivo e l√™-lo logo em seguida!

                # escrita
                file = open("arquivo.txt", mode="w")
                file.write("Trybe S2")
                file.close()

                # leitura
                file = open("arquivo.txt", mode="r")
                content = file.read()
                print(content)
                file.close()  # n√£o podemos esquecer de fechar o arquivo


    
        Um arquivo √© tamb√©m um iter√°vel, ou seja, pode ser percorrido em um la√ßo de repeti√ß√£o. A cada itera√ß√£o, uma nova linha √© retornada. Vamos fazer igual ao exemplo anterior, por√©m dessa vez vamos escrever mais de uma linha!


                # escrita
                file = open("arquivo.txt", mode="w")
                LINES = ["Ol√°\n", "mundo\n", "belo\n", "do\n", "Python\n"]
                file.writelines(LINES)
                file.close()

                # leitura
                file = open("arquivo.txt", mode="r")
                for line in file:
                    print(line)  # n√£o esque√ßa que a quebra de linha tamb√©m √© um caractere da linha
                file.close()  # n√£o podemos esquecer de fechar o arquivo




        Al√©m de arquivos textuais (como os que manipulamos at√© agora), tamb√©m existem arquivos bin√°rios. Eles s√£o arquivos que cont√™m uma s√©rie de bytes e a sua leitura pode variar de acordo com o arquivo. Nesse caso, devemos acrescentar um b ao par√¢metro mode, indicando que ser√° utilizado o modo bin√°rio.


        As opera√ß√µes s√£o similares a de um arquivo textual. Por√©m tanto a escrita quanto a leitura devem ser feitas utilizando bytes.


                # escrita
                file = open("arquivo.dat", mode="wb")
                file.write(b"C\xc3\xa1ssio 30")  # o prefixo b em uma string indica que seu valor est√° codificado em bytes
                file.close()

                # leitura
                file = open("arquivo.dat", mode="rb")
                content = file.read()
                print(content)  # sa√≠da: b'C\xc3\xa1ssio 30'
                file.close()  # n√£o podemos esquecer de fechar o arquivo





    -----------------------------------------------------------------------------------------------
    Lidando com exce√ß√µes

        Erros podem acontecer: um arquivo pode n√£o existir, permiss√µes podem faltar e codifica√ß√µes podem falhar. Por isso temos de garantir que, ainda que um erro ocorra, faremos o fechamento do nosso arquivo.

        Como conseguimos lidar com erros em Python? Vamos agora falar sobre exce√ß√µes!

        H√° pelo menos dois tipos de erros que podem ser destacados: erros de sintaxe e exce√ß√µes.



        Erros de Sintaxe

            Erros de sintaxe ocorrem quando o c√≥digo utiliza recursos inexistentes da linguagem que n√£o consegue interpret√°-los. √â como executar print{"Ol√°, mundo!"} em vez de print("Ol√°, mundo!").



        Exce√ß√µes

            J√° as exce√ß√µes ocorrem durante a execu√ß√£o e resultam em mensagem de erro. Veja exemplos de exce√ß√µes:


                        print(10 * (1 / 0))
                        # Traceback (most recent call last):
                        #   File "<stdin>", line 1, in <module>
                        # ZeroDivisionError: division by zero

                        print(4 + spam * 3)
                        # Traceback (most recent call last):
                        #   File "<stdin>", line 1, in <module>
                        # NameError: name 'spam' is not defined

                        print('2' + 2)
                        # Traceback (most recent call last):
                        #   File "<stdin>", line 1, in <module>
                        # TypeError: can only concatenate str (not "int") to str


            Observe que, apenas no exemplo acima, podemos observar tr√™s exce√ß√µes: ZeroDivisionError, NameError e TypeError. A lista completa de exce√ß√µes j√° embutidas na linguagem pode ser vista aqui (https://docs.python.org/pt-br/3/library/exceptions.html#bltin-exceptions)

            


        Tratamento de exce√ß√µes

            Para tratar exce√ß√µes utilizamos o conjunto de instru√ß√µes try, com as palavras reservadas try e except. O funcionamento dessa cl√°usula ocorre da seguinte forma:

                -> Se nenhuma exce√ß√£o ocorrer, a cl√°usula except √© ignorada e a execu√ß√£o da instru√ß√£o try √© finalizada.

                -> Se ocorrer uma exce√ß√£o durante a execu√ß√£o da cl√°usula try, as instru√ß√µes remanescentes na cl√°usula s√£o ignoradas. Se o tipo da exce√ß√£o ocorrida tiver sido previsto em algum except, ent√£o essa cl√°usula ser√° executada.

                -> Se n√£o existir nenhum tratador previsto para tal exce√ß√£o, trata-se de uma exce√ß√£o n√£o tratada e a execu√ß√£o do programa termina com uma mensagem de erro.            

            
            Vamos agora ver um exemplo de tratamento de exce√ß√µes:

                    while True:
                    try:
                        x = int(input("Please enter a number: "))
                        break
                    except ValueError:
                        print("Oops!  That was no valid number.  Try again...")





        
        Lidando com exce√ß√µes enquanto manipulamos arquivos
            
            Vamos ver agora como podemos nos prevenir de poss√≠veis erros que ocorrem quando manipulamos arquivos. Sempre devemos fechar um arquivo e podemos, em um bloco try, fazer isso utilizando a instru√ß√£o finally ou else. O finally √© uma outra cl√°usula do conjunto try, cuja finalidade √© permitir a implementa√ß√£o de a√ß√µes de limpeza, que sempre devem ser executadas independentemente da ocorr√™ncia de a√ß√µes. J√° o else ocorre sempre que todo o try for bem sucedido.
            
                    try:
                        arquivo = open("arquivo.txt", "r")
                    except OSError:
                        # ser√° executado caso haja uma exce√ß√£o
                        print("arquivo inexistente")
                    else:
                        # ser√° executado se tudo ocorrer bem no try
                        print("arquivo manipulado e fechado com sucesso")
                        arquivo.close()
                    finally:
                        # ser√° sempre executado, independentemente de erro
                        print("Tentativa de abrir arquivo")                
                


            Como estamos abrindo o arquivo em modo de leitura, uma exce√ß√£o ser√° levantada caso ele n√£o exista, executando as cl√°usulas except e finally. Entretanto, se alterarmos o modo para escrita, o arquivo ser√° criado mesmo se inexistente, executando as cl√°usulas else e finally.


            Este padr√£o √© muito comum, n√£o s√≥ em arquivos, mas tamb√©m em outros recursos que devemos utilizar e liberar ao final (conex√µes de bancos de dados, por exemplo). T√£o comum que o Python tem um mecanismo pr√≥prio para lidar com isto.

            O with √© a palavra reservada para gerenciamento de contexto. Este gerenciamento (with) √© utilizado para encapsular a utiliza√ß√£o de um recurso, garantindo que certas a√ß√µes sejam tomadas independentemente se ocorreu ou n√£o um erro naquele contexto.

            A fun√ß√£o open retorna um objeto que se comporta como um gerenciador de contexto de arquivo que ser√° respons√°vel por abrir e fechar o mesmo. Isto significa que o arquivo possui mecanismos especiais que, quando invocados utilizando with, alocam um determinado recurso ‚Äî um arquivo ‚Äî e o liberam quando o bloco for finalizado.


                    # Criamos um contexto, limitando o escopo onde o arquivo est√° aberto.
                    # O uso do "as" aqui √© somente para atribuir o valor utilizado no contexto √† vari√°vel file
                    with open("arquivo.txt", "w") as file:
                        file.write("Michelle 27\n")
                    # como estamos fora do contexto, o arquivo foi fechado
                    print(file.closed)


            üí° J√° vimos a utiliza√ß√£o de gerenciadores de contexto em testes. L√°, capturamos exce√ß√µes que ocorrem e verificamos se naquele contexto a exce√ß√£o lan√ßada era a esperada. N√£o h√° um recurso a ser liberado, mas estamos garantindo que uma asser√ß√£o ser√° feita naquele contexto.

            




    -------------------------------------------------------------------------------------------------------------
    Manipulando arquivos JSON

        JSON √© um formato textual muito utilizado para integra√ß√£o de sistemas. Ele √© baseado em um subconjunto de regras JavaScript, embora seja independente de linguagem.
    
        Por sua legibilidade e tamanho (√© bem leve), al√©m da facilidade de leitura e escrita por seres humanos e m√°quinas, vem sendo bastante utilizado na web e para troca de informa√ß√µes entre sistemas.

        Alguns exemplos de utiliza√ß√£o incluem comunica√ß√£o back-end e front-end, e comunica√ß√£o com sistemas externos (gateways de pagamento, por exemplo) ou internos (como um sistema de autentica√ß√£o).

        A linguagem Python j√° inclui um m√≥dulo para manipula√ß√£o desse tipo de arquivo e seu nome √© json.

        Seus principais m√©todos para manipula√ß√£o s√£o: load, loads, dump, dumps.


        Para demonstrar como √© feita a manipula√ß√£o de arquivos JSON, vamos utilizar o arquivo pokemons.json que √© uma lista de pokemons com suas informa√ß√µes chave. (https://lms-assets.betrybe.com/lms/pokemons.json)

        üí° Para fazer o exemplo, coloque o arquivo pokemons.json no mesmo diret√≥rio em que estar√° o seu script.


                    import json  # json √© um modulo que vem embutido, por√©m precisamos import√°-lo


                    with open("pokemons.json") as file:
                        content = file.read()  # leitura do arquivo
                        pokemons = json.loads(content)["results"]  # o conte√∫do √© transformado em estrutura python equivalente, dicion√°rio neste caso.
                        # acessamos a chave results que √© onde cont√©m nossa lista de pokemons

                    print(pokemons[0])  # imprime o primeiro pokemon da lista





        A leitura pode ser feita diretamente do arquivo, utilizando o m√©todo load ao inv√©s de loads. O loads carrega o JSON a partir de um texto e o load carrega o JSON a partir de um arquivo.
        

                    import json


                    with open("pokemons.json") as file:
                        pokemons = json.load(file)["results"]

                    print(pokemons[0])  # imprime o primeiro pokemon da lista




        A escrita de arquivos no formato JSON √© similar √† escrita de arquivos comuns, por√©m temos que transformar os dados primeiro.

                    import json

                    # Leitura de todos os pokemons
                    with open("pokemons.json") as file:
                        pokemons = json.load(file)["results"]

                    # Separamos somente os do tipo grama
                    grass_type_pokemons = [
                        pokemon for pokemon in pokemons if "Grass" in pokemon["type"]
                    ]

                    # Abre o arquivo para escrevermos apenas o pokemons do tipo grama
                    with open("grass_pokemons.json", "w") as file:
                        json_to_write = json.dumps(
                            grass_type_pokemons
                        )  # convers√£o de Python para o formato json (str)
                        file.write(json_to_write)



        Assim como a desserializa√ß√£o, que faz a transforma√ß√£o de texto em formato JSON para Python, a serializa√ß√£o (caminho inverso) possui um m√©todo equivalente para escrever em arquivos de forma direta.


                    import json

                    # leitura de todos os pokemons
                    with open("pokemons.json") as file:
                        pokemons = json.load(file)["results"]

                    # separamos somente os do tipo grama
                    grass_type_pokemons = [
                        pokemon for pokemon in pokemons if "Grass" in pokemon["type"]
                    ]

                    # abre o arquivo para escrita
                    with open("grass_pokemons.json", "w") as file:
                        # escreve no arquivo j√° transformando em formato json a estrutura
                        json.dump(grass_type_pokemons, file)



        OBS: üí° Arquivos JSON n√£o seguem a nomenclatura habitual de leitura e escrita (write e read), pois s√£o considerados formatos de serializa√ß√£o de dados. Seguem ent√£o as mesmas nomenclaturas utilizadas em m√≥dulos como marshal e pikle, que tamb√©m s√£o formatos de serializa√ß√£o.





    ----------------------------------------------------------------------------------------------------------
    Manipulando arquivos CSV

        O formato CSV (Comma Separated Values) √© muito comum em exporta√ß√µes de planilhas de dados e base de dados. Foi utilizado por muito tempo antes de sua defini√ß√£o formal, o que gerou uma despadroniza√ß√£o deste formato e o surgimento de v√°rios dialetos.

        Cada dialeto tem seus pr√≥prios delimitadores e caracteres de cita√ß√£o, por√©m o formato geral √© semelhante o suficiente para utilizarmos o mesmo m√≥dulo para este processamento.

        Ainda que seu nome indique que o delimitador seja a ‚Äú,‚Äú (v√≠rgula), existem varia√ß√µes que utilizam ‚Äú;‚Äú (ponto e v√≠rgula) ou at√© mesmo tabula√ß√µes (‚Äú\t‚Äú).

        Sem d√∫vidas, an√°lise de dados √© o que se destaca quando estamos falando sobre manipular arquivos CSV.

        Vamos analisar uma base de dados a respeito dos cursos de gradua√ß√£o oferecidos pela Universidade de Bras√≠lia (UnB). O arquivo utilizado √© o graduacao_unb.csv. (j√° baixei pro diret√≥rio do dia)

        O m√≥dulo csv, cont√©m duas principais fun√ß√µes:

            -> Um leitor (reader) que nos ajuda a ler o conte√∫do, j√° fazendo as transforma√ß√µes dos valores para Python;

            -> E um escritor (writer) para facilitar a escrita nesse formato.



            import csv

            with open("graduacao_unb.csv", encoding = "utf-8") as file:
                graduacao_reader = csv.reader(file, delimiter=",", quotechar='"')
                # Usando o conceito de desempacotamento
                header, *data = graduacao_reader

            print(data)




        O leitor define como dialeto padr√£o excel, o que significa dizer que o delimitador de campos ser√° ‚Äú,‚Äú e o caractere de cita√ß√£o ser√° aspas duplas ("). Uma forma de modificar estes padr√µes √© definindo-os de forma diferente na cria√ß√£o do leitor. Al√©m disso, o leitor ir√° usar o decodificador padr√£o do sistema para decodificar em unicode o arquivo .csv. Para utilizar um decodificador diferente, deve ser passado o argumento encoding com o valor do decodificador esperado. Um leitor de .csv pode ser percorrido utilizando o la√ßo de repeti√ß√£o for e, a cada itera√ß√£o, retorna uma nova linha j√° transformada em uma lista Python com seus respectivos valores.


        Podemos fazer uma an√°lise e verificar quantos cursos s√£o ofertados por departamento. Em seguida salvamos o resultado tamb√©m no formato .csv:

                
                import csv

                with open("graduacao_unb.csv", encoding="utf8") as file:
                    graduacao_reader = csv.reader(file, delimiter=",", quotechar='"')
                    # Usando o conceito de desempacotamento
                    header, *data = graduacao_reader

                group_by_department = {}
                for row in data:
                    department = row[15]
                    if department not in group_by_department:
                        group_by_department[department] = 0
                    group_by_department[department] += 1

                # Escreve o relat√≥rio em .csv
                # Abre um arquivo para escrita
                with open("department_report.csv", "w", encoding = "utf-8") as file:
                    writer = csv.writer(file)

                    # Escreve o cabe√ßalho
                    headers = [
                        "Departamento",
                        "Total de Cursos",
                    ]
                    writer.writerow(headers)

                    # Escreve as linhas de dados
                    # Desempacotamento de valores
                    for department, grades in group_by_department.items():
                        # Agrupa o dado com o turno
                        row = [
                            department,
                            grades,
                        ]
                        writer.writerow(row)




        Existem ainda o leitor e o escritor baseados em dicion√°rios. A principal vantagem √© que n√£o precisamos manipular os √≠ndices para acessar os dados das colunas. A desvantagem √© o espa√ßo ocupado em mem√≥ria (que √© maior que o comum), devido √† estrutura de dados utilizada.

            
                import csv

                # l√™ os dados
                with open("graduacao_unb.csv", encoding = "utf-8") as file:
                    graduacao_reader = csv.DictReader(file, delimiter=",", quotechar='"')

                    # a linha de cabe√ßalhos √© utilizada como chave do dicion√°rio
                    # agrupa cursos por departamento
                    group_by_department = {}
                    for row in graduacao_reader:
                        department = row["unidade_responsavel"]
                        if department not in group_by_department:
                            group_by_department[department] = 0
                        group_by_department[department] += 1

                # abre um arquivo para escrita
                with open("new_department_report.csv", "w", encoding = "utf-8") as file:
                    # os valores a serem escritos devem ser dicion√°rios
                    headers = [
                        "Departamento",
                        "Total de Cursos",
                    ]
                    # √â necess√°rio passar o arquivo e o cabe√ßalho
                    writer = csv.DictWriter(file, fieldnames=headers)
                    writer.writeheader()
                    # escreve as linhas de dados
                    for department, grades in group_by_department.items():
                        # Agrupa o dado com o turno
                        row = {"Departamento": department, "Total de Cursos": grades}
                        writer.writerow(row)



        Ainda que a manipula√ß√£o de arquivos seja algo trivial, caso precise fazer an√°lises de dados, leve em considera√ß√£o bibliotecas como Pandas (https://pandas.pydata.org/). Elas foram constru√≠das e s√£o mantidas justamente para atender e facilitar este objetivo.









-----------------------------------------------------------------------------------------------------------------

DIA 03: TESTES PYTHON


    Testes automatizados

        Atrav√©s de testes automatizados, a pessoa desenvolvedora √© capaz de identificar mais facilmente um bug ou verificar que altera√ß√µes do c√≥digo n√£o afetaram o comportamento esperado do sistema.

        Em nosso curso utilizaremos a biblioteca pytest, um framework que facilita a escrita de testes simples, mas capazes de testar funcionalidades complexas em aplica√ß√µes e bibliotecas.

        ‚ö†Ô∏è Lembre-se de instalar a biblioteca somente no ambiente virtual do seu projeto.

        A instala√ß√£o √© feita atrav√©s do pip utilizando o comando:

                python3 -m pip install pytest

        
        E podemos verificar utilizando o comando:
        
                python3 -m pytest --version
        

        Que tal vermos um exemplo?
                
                // codigo.py

                def is_odd(number):
                    'Retorna True se um n√∫mero √© √≠mpar, sen√£o False.'
                    return number % 2 != 0


                // test_codigo.py

                from codigo import is_odd

                def test_is_odd_when_number_is_odd_returns_true():
                    'Para um n√∫mero √≠mpar a fun√ß√£o deve retornar o valor True'
                    assert is_odd(3) is True

                def test_is_odd_when_number_is_even_returns_false():
                    'Para um n√∫mero par a fun√ß√£o deve retornar o valor False'
                    assert is_odd(2) is False



        Notem que o nome do arquivo de testes possui o prefixo test_, assim como a defini√ß√£o das fun√ß√µes de teste. Isto √© necess√°rio para que seus testes sejam descobertos pela ferramenta.

        Uma fun√ß√£o de teste √© similar a qualquer outra, por√©m tem o prop√≥sito de verificar se o resultado obtido foi o mesmo do esperado. No c√≥digo, isto pode ser visto atrav√©s da utiliza√ß√£o da palavra reservada assert.

        O comando assert funciona da seguinte maneira: caso a express√£o recebida seja verdadeira (avaliada como True), nada acontece. Por√©m, caso seja falsa (avaliada como False), uma exce√ß√£o do tipo AssertionError √© lan√ßada. A pytest captura este erro e tenta apresentar uma compara√ß√£o entre o esperado e o recebido da melhor maneira poss√≠vel.


        Vamos rodar nossos testes e ver o resultado? Vamos utilizar o comando:

                python3 -m pytest




    ----------------------------------------------------------------------------------------------------
    Testando falhas
    
        Erros acontecem e nem sempre s√£o inesperados. O Python utiliza exce√ß√µes para sinalizar que ocorreram erros durante a execu√ß√£o de um c√≥digo e que nem sempre s√£o fatais.

        Podemos escrever testes que verificam que um erro deve ocorrer a partir de uma determinada entrada:


                // codigo.py

                # ...

                def divide(a_number, other_number):
                    "Retorna a divis√£o de a_number por other_number"
                    return a_number / other_number




                // test_codigo.py

                import pytest
                from codigo import is_odd, divide

                # ...

                def test_divide_when_other_number_is_zero_raises_an_exception():
                    with pytest.raises(ZeroDivisionError, match="division by zero"):
                        divide(2, 0)





    ---------------------------------------------------------------------------------------------------
    Um pouco de contexto

        Quando escrevemos testes, pensamos em cen√°rios distintos que podem ocorrer no nosso sistema: ‚Äúdado um arquivo com as seguintes linhas‚Äù, ‚Äúvisto que temos um banco de dados com um dado registro‚Äù ou ‚Äúa partir de um cliente web‚Äù. Damos o nome de test fixture (ou apenas fixture) √†s precondi√ß√µes ou estados necess√°rios para a execu√ß√£o de um teste.

        Cada teste pode ter seu pr√≥prio cen√°rio (contexto) ou compartilh√°-lo com outros testes.


                // test_codigo.py

                # get_most_ordered_dish_per_costumer √© uma fun√ß√£o que retorna o prato mais pedido por uma
                # determinada pessoa cliente, considerando que os pedidos est√£o em uma lista.

                # get_order_frequency_per_costumer √© uma fun√ß√£o que retorna a frequ√™ncia que uma determinada
                # pessoa cliente pede um determinado prato, considerando que os pedidos est√£o em uma lista.


                # uma fixture utilizando a biblioteca pytest
                # √© definida utilizando a sintaxe abaixo
                @pytest.fixture
                def orders():
                    """Nosso cen√°rio (contexto) temos os seguintes pedidos"""
                    return [
                        {"customer": "maria", "order": "pizza", "day": "ter√ßa-feira"},
                        {"customer": "joao", "order": "hamburger", "day": "ter√ßa-feira"},
                        {"customer": "maria", "order": "pizza", "day": "quarta-feira"},
                        {"customer": "maria", "order": "hamburger", "day": "quinta-feira"},
                    ]

                # estamos adicionando a fixture "orders" ao teste
                # ou seja, temos um contexto onde os pedidos s√£o os definidos anteriormente
                def test_get_most_ordered_dish_per_costumer_when_customer_is_maria(orders):
                    assert get_most_ordered_dish_per_costumer(orders, "maria") == "pizza"

                # novamente adicionamos um cen√°rio (contexto) ao teste onde os pedidos realizados s√£o os
                # definidos na fixture
                def test_get_order_frequency_per_costumer_when_customer_is_joao_and_order_is_pizza(orders):
                    assert get_order_frequency_per_costumer(orders, "joao", "pizza") == 0

                def test_get_order_frequency_per_costumer_when_customer_is_maria_and_order_is_hamburger(orders):
                    assert get_order_frequency_per_costumer(orders, "maria", "hamburger") == 1




        √â importante ressaltar que este contexto poderia ser a abertura de uma conex√£o com o banco de dados, uma refer√™ncia √† conex√£o a um cliente web, um arquivo tempor√°rio ou qualquer outro contexto. Tamb√©m vale lembrar que √© poss√≠vel usar mais de um contexto por teste caso seja necess√°rio, bem como um contexto dentro de outro.

        ‚ö†Ô∏è Aten√ß√£o: Voc√™ deve ter notado o uso de um @ no c√≥digo. Ele √© o decorator do Python. Com ele podemos adicionar funcionalidades aos nossos c√≥digos, ‚Äúdecorando‚Äù o que uma outra fun√ß√£o faz (no caso acima, a fun√ß√£o pytest.fixure). N√£o se preocupe com essa sintaxe por enquanto. Voc√™ poder√° ler mais sobre decorators aqui.(https://docs.python.org/pt-br/3/glossary.html#term-decorator)







    -------------------------------------------------------------------------------------------------------------
    Dubl√™s de teste

        Em testes automatizados (de unidade) √© desejado que cada teste n√£o interfira no estado manipulado por outro teste, e tamb√©m que recursos externos (arquivos, internet, banco de dados) n√£o atrapalhem a sua execu√ß√£o. Por isso, √© muito comum a utiliza√ß√£o de dubl√™s de testes para simular estes recursos externos.

        Estes componentes simulados de software s√£o chamados de mock (de forma gen√©rica), mas existem diversas t√©cnicas espec√≠ficas de simula√ß√µes que nos ajudam a escrever os testes.

        Podemos substituir componentes para que retornem um determinado valor simulado ou podemos substituir os componentes por objetos falsos que registram as informa√ß√µes sobre sua invoca√ß√£o, como o n√∫mero de vezes em que foram chamados ou os par√¢metros com o qual foram chamados.

        Na literatura encontramos as t√©cnicas de dubl√™ com os nomes fakes, mocks, stubs e spies. De uma forma bem resumida, podemos defini-las da seguinte maneira:

            -> Fakes: Objetos que possuem implementa√ß√µes funcionais, por√©m normalmente simplificadas;

            -> Mocks: S√£o pr√© programados para verificar as chamadas das fun√ß√µes que receberem;

            -> Stubs: Fornecem respostas predefinidas;

            -> Spies: S√£o como stubs, mas tamb√©m armazenam informa√ß√µes de como foram chamados.

        Caso queira mais detalhes, d√™ uma olhada no artigo do Martin Fowler sobre o assunto ou no material complementar sobre dubl√™s de testes que se encontra na se√ß√£o ‚ÄúRecursos adicionais‚Äù. (https://martinfowler.com/bliki/TestDouble.html)

        Vamos analisar dois cen√°rios e escrever seus respectivos testes utilizando dubl√™s, evitando assim a depend√™ncia externa a um arquivo real.

        No primeiro cen√°rio n√≥s temos nossa depend√™ncia externa (o arquivo) sendo recebido como par√¢metro.


        

                // pokemon.py


                import json

                def retrieve_pokemons_by_type(type, reader):
                    # l√™ o conteudo de reader e o transforma de json
                    # para dicion√°rio
                    pokemons = json.load(reader)["results"]
                    # filtra somente os pokemons do tipo escolhido
                    pokemons_by_type = [
                        pokemon for pokemon in pokemons if type in pokemon["type"]
                    ]
                    return pokemons_by_type




        Vamos utilizar uma t√©cnica onde substituiremos a abertura do nosso arquivo real por um objeto que possui as implementa√ß√µes funcionais de um arquivo (m√©todo read, necess√°rio na opera√ß√£o de leitura). Este objeto ser√° alocado na mem√≥ria, ‚Äúsimulando‚Äù nosso arquivo real.


            
                // test_pokemon.py

                import json
                import pytest
                from pokemon import retrieve_pokemons_by_type
                from io import StringIO
                # Criamos o contexto de um pokemon do tipo grama
                @pytest.fixture
                def grass_type_pokemon():
                    return {
                        "national_number": "001",
                        "evolution": None,
                        "name": "Bulbasaur",
                        "type": ["Grass", "Poison"],
                        "total": 318,
                        "hp": 45,
                        "attack": 49,
                        "defense": 49,
                        "sp_atk": 65,
                        "sp_def": 65,
                        "speed": 45,
                    }
                # Criamos o contexto de um pokemon do tipo √°gua
                @pytest.fixture
                def water_type_pokemon():
                    return {
                        "national_number": "007",
                        "evolution": None,
                        "name": "Squirtle",
                        "type": ["Water"],
                        "total": 314,
                        "hp": 44,
                        "attack": 48,
                        "defense": 65,
                        "sp_atk": 50,
                        "sp_def": 64,
                        "speed": 43,
                    }


                def test_retrieve_pokemons_by_type(grass_type_pokemon, water_type_pokemon):
                    # criamos um arquivo em mem√≥ria que o seu conte√∫do s√£o os dois pokemons
                    fake_file = StringIO(
                        json.dumps({"results": [grass_type_pokemon, water_type_pokemon]})
                    )
                    # quando pesquisamos por pokemons do tipo grama,
                    # o pokemon do tipo √°gua n√£o deve ser retornado
                    assert grass_type_pokemon in retrieve_pokemons_by_type("Grass", fake_file)





        ----
        Um segundo cen√°rio √© onde a fun√ß√£o espera o nome de um arquivo e a abertura do mesmo acontece dentro da fun√ß√£o.

            
            // pokemon.py


            import json

            def retrieve_pokemons_by_type(type, filepath):
                with open(filepath) as file:
                    pokemons = json.load(file)["results"]
                    pokemons_by_type = [
                        pokemon for pokemon in pokemons if type in pokemon["type"]
                    ]
                    return pokemons_by_type




        Para escrever este teste, vamos aproveitar da natureza din√¢mica da linguagem e substituir o m√©todo open em tempo de execu√ß√£o por um objeto mock_open, que j√° vem embutido na linguagem e se comporta como o open, retornando o que foi definido em read_data como seu conte√∫do. Um detalhe interessante √© que esse objeto obtido atrav√©s da fun√ß√£o mock_open tamb√©m possui a capacidade de armazenar informa√ß√µes sobre como foram as chamadas de seus m√©todos e os par√¢metros recebidos.


            // test_pokemon.py


            import json
            from unittest.mock import mock_open, patch
            from pokemon import retrieve_pokemons_by_type

            def test_retrieve_pokemons_by_type():
                # definimos um pokemon do tipo grama
                grass_type_pokemon = {
                    "national_number": "001",
                    "evolution": None,
                    "name": "Bulbasaur",
                    "type": ["Grass", "Poison"],
                    "total": 318,
                    "hp": 45,
                    "attack": 49,
                    "defense": 49,
                    "sp_atk": 65,
                    "sp_def": 65,
                    "speed": 45,
                }
                # definimos tamb√©m um pokemon do tipo √°gua
                water_type_pokemon = {
                    "national_number": "007",
                    "evolution": None,
                    "name": "Squirtle",
                    "type": ["Water"],
                    "total": 314,
                    "hp": 44,
                    "attack": 48,
                    "defense": 65,
                    "sp_atk": 50,
                    "sp_def": 64,
                    "speed": 43,
                }
                pokemon_json_content = json.dumps({"results": [grass_type_pokemon, water_type_pokemon]})
                # substitu√≠mos a fun√ß√£o padr√£o do python open por mock_open
                # uma vers√£o que se comporta de forma parecida, por√©m simulada
                with patch("builtins.open", mock_open(read_data=pokemon_json_content)):
                    # repare que o nome do arquivo n√£o √© importante aqui
                    # a esses par√¢metros n√£o utilizados damos o nome de dummies
                    # como neste contexto alteramos o open pelo mock_open,
                    # o argumento "dummy" poderia ser substitu√≠do por qualquer coisa, j√° que n√£o ser√° utilizado pela fun√ß√£o
                    assert retrieve_pokemons_by_type("Grass", "dummy") == [
                        grass_type_pokemon
                    ]




    
        A primeira abordagem torna o c√≥digo menos acoplado a um arquivo e nos permite utilizar qualquer objeto (que tenha o m√©todo reader) em seu lugar. Assim, essa fun√ß√£o pode ser reutilizada, por exemplo, para ler pokemons a partir de uma requisi√ß√£o web ou outra fonte.

        üí° Testes de unidade s√£o muito importantes, mas n√£o se esque√ßa de testar tamb√©m a integra√ß√£o de suas fun√ß√µes e a funcionalidade como um todo. 























